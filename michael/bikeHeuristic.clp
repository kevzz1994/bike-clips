(defglobal ?*nodGen* = 0)
(defglobal ?*sal* = 1)
(defglobal ?*neighbourhood* = (create$ A 1 B 2 C 2 D 2 E 2 J 2 F 3 G 3 H 3 I 3 O 3 K 4 L 4 M 4 N 4 P 5 Q 5 R 6))
(defglobal ?*bikePts* = (create$ A B H J K M R N))

(deffunction control (?pos ?des ?arc ?bike ?cost)
	(bind ?neiPos (nth$ (+ 1 (member$ ?pos ?*neighbourhood*)) ?*neighbourhood*))
	(bind ?neiDes (nth$ (+ 1 (member$ ?des ?*neighbourhood*)) ?*neighbourhood*))
	;(printout t "pos: " ?pos " " ?neiPos crlf)
	;(printout t "des: " ?des " " ?neiDes crlf)
	
	(if (eq ?neiPos ?neiDes)
		then (bind ?*sal* 1)
		else (bind ?*sal* (abs (- ?neiDes ?neiPos)))
	)
	(bind ?*sal* (* ?*sal* ?arc))
	(if (not (and (eq ?bike 1) (not (member$ ?pos ?*bikePts*))))
		then (bind ?*sal* (div ?*sal* 2))
	)
	(bind ?*sal* (+ ?*sal* ?cost))
	;(printout t "sal: " ?*sal* crlf)
)

(defrule take
	(declare (salience (- 0 ?*sal*)))
	(person pos ?p des ?d bike 0 level ?l cost ?c movement ?mov)
	(bikePoints $?x ?p $?y)
	(arc $? ?p ?arc $?)
	(test (neq ?mov drop))
	(maxDepth ?prof)
    (test (< ?l ?prof))
	(test (control ?p ?d ?arc 0.5 (+ 1 ?c)))
	=>
	(assert (person pos ?p des ?d bike 1 level (+ ?l 1) cost (+ ?c 1) movement take))
	(bind ?*nodGen* (+ ?*nodGen* 1))
)

(defrule cycle
	(declare (salience (- 0 ?*sal*)))
	(person pos ?p des ?d bike 1 level ?l cost ?c movement ?mov)
	(map pos1 ?p pos2 ?p2 cost ?cW bike 1)
	(arc $? ?p2 ?arc $?)
	(test (neq ?mov ?p2))
	(maxDepth ?prof)
    (test (< ?l ?prof))
	(test (control ?p2 ?d ?arc 0.5 (+ ?c (div ?cW 2))))
	=>
	(assert (person pos ?p2 des ?d bike 1 level (+ ?l 1) cost (+ ?c (div ?cW 2)) movement ?p))
	(bind ?*nodGen* (+ ?*nodGen* 1))
)

(defrule drop
	(declare (salience (- 0 ?*sal*)))
	(person pos ?p des ?d bike 1 level ?l cost ?c movement ?mov)
	(bikePoints $?x ?p $?y)
	(arc $? ?p ?arc $?)
	(test (neq ?mov take))
	(maxDepth ?prof)
    (test (< ?l ?prof))
	(test (control ?p ?d ?arc 0.5 (+ 1 ?c)))
	=>
	(assert (person pos ?p des ?d bike 0 level (+ ?l 1) cost (+ ?c 1) movement drop))
	(bind ?*nodGen* (+ ?*nodGen* 1))
)

(defrule walk
	(declare (salience (- 0 ?*sal*)))
	(person pos ?p des ?d bike 0 level ?l cost ?c movement ?mov)
	(map pos1 ?p pos2 ?p2 cost ?cW bike ?)
	(arc $? ?p2 ?arc $?)
	(test (neq ?mov ?p2))
	(maxDepth ?prof)
    (test (< ?l ?prof))
	(test (control ?p2 ?d ?arc 1 (+ ?c ?cW)))
	=>
	(assert (person pos ?p2 des ?d bike 0 level (+ ?l 1) cost (+ ?c ?cW) movement ?p))
	(bind ?*nodGen* (+ ?*nodGen* 1))
)

(defrule stop
	(declare (salience 100))
	?f<-(person pos ?p des ?p bike 0 level ?l cost ?c movement ?)
	=>
	(printout t "Solution found at level " ?l crlf)
	(printout t "Cost is " ?c crlf)
	(printout t "Goal fact " ?f crlf)
	(printout t "Number of expanded nodes " ?*nodGen* crlf)
	(halt)
)


(deffunction start ()
	(set-salience-evaluation when-activated)
	(reset)
	(printout t "Maximum depth:= ")
	(bind ?mDepth (read))
			
	(printout t "Starting position: (A,B,C etc.)" crlf)
	(bind ?mPos (read))
	(printout t "Destination: (A,B,C etc.)" crlf)
	(bind ?mDes (read))
	
	(printout t "ctrl+R to run the program" crlf)
	
	(assert (maxDepth ?mDepth))
	(assert (map pos1 A pos2 B cost 10 bike 1)
	(map pos1 A pos2 C cost 8 bike 0)
	(map pos1 A pos2 E cost 10 bike 1)
	(map pos1 B pos2 C cost 5 bike 0)
	(map pos1 C pos2 D cost 6 bike 0)
	(map pos1 E pos2 J cost 9 bike 1)
	(map pos1 B pos2 F cost 6 bike 0)
	(map pos1 C pos2 G cost 6 bike 0)
	(map pos1 C pos2 H cost 6 bike 0)
	(map pos1 D pos2 H cost 14 bike 1)
	(map pos1 E pos2 I cost 20 bike 0)
	(map pos1 J pos2 O cost 7 bike 1)
	(map pos1 F pos2 K cost 10 bike 0)
	(map pos1 F pos2 L cost 6 bike 0)
	(map pos1 G pos2 L cost 9 bike 0)
	(map pos1 G pos2 M cost 12 bike 0)
	(map pos1 G pos2 H cost 8 bike 0)
	(map pos1 H pos2 I cost 12 bike 1)
	(map pos1 I pos2 O cost 2 bike 0)
	(map pos1 K pos2 L cost 2 bike 1)
	(map pos1 L pos2 M cost 7 bike 1)
	(map pos1 O pos2 N cost 8 bike 1)
	(map pos1 L pos2 P cost 6 bike 1)
	(map pos1 M pos2 Q cost 2 bike 0)
	(map pos1 N pos2 Q cost 6 bike 0)
	(map pos1 P pos2 R cost 4 bike 1)
	(map pos1 P pos2 Q cost 2 bike 0)
	(map pos1 Q pos2 R cost 3 bike 0)
	;;----------------------------------------
	(map pos1 C pos2 A cost 8 bike 0)
	(map pos1 E pos2 A cost 10 bike 1)
	(map pos1 C pos2 B cost 5 bike 0)
	(map pos1 D pos2 C cost 6 bike 0)
	(map pos1 J pos2 E cost 9 bike 1)
	(map pos1 F pos2 B cost 6 bike 0)
	(map pos1 G pos2 C cost 6 bike 0)
	(map pos1 H pos2 C cost 6 bike 0)
	(map pos1 H pos2 D cost 14 bike 1)
	(map pos1 I pos2 E cost 20 bike 0)
	(map pos1 O pos2 J cost 7 bike 1)
	(map pos1 K pos2 F cost 10 bike 0)
	(map pos1 L pos2 F cost 6 bike 0)
	(map pos1 L pos2 G cost 9 bike 0)
	(map pos1 M pos2 G cost 12 bike 0)
	(map pos1 H pos2 G cost 8 bike 0)
	(map pos1 I pos2 H cost 12 bike 1)
	(map pos1 O pos2 I cost 2 bike 0)
	(map pos1 L pos2 K cost 2 bike 1)
	(map pos1 M pos2 L cost 7 bike 1)
	(map pos1 N pos2 O cost 8 bike 1)
	(map pos1 P pos2 L cost 6 bike 1)
	(map pos1 Q pos2 M cost 2 bike 0)
	(map pos1 Q pos2 N cost 6 bike 0)
	(map pos1 R pos2 P cost 4 bike 1)
	(map pos1 Q pos2 P cost 2 bike 0)
	(map pos1 R pos2 Q cost 3 bike 0)
	)
	
	(assert 
	(arc A 8 B 5 C 5 D 6 E 9 F 6 G 6 H 6 I 2 J 7 O 2 K 2 L 2 M 2 N 6 P 2 Q 2 R 3)
	)
	
	(assert (bikePoints A B H J K M R N))
	(assert (person pos ?mPos des ?mDes bike 0 level 0 cost 0 movement null)) ;; bike = 0 no bike; bike = 1 person has a bike
	;; movement: take - bike was just taken, drop - bike was just dropped, Letter (A,B,C etc.) where we came from
	
	
)